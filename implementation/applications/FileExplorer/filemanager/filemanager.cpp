
// Qt's headers
#include <QtCore/QList>
#include <QtCore/QUrl>
#include <QtCore/QPersistentModelIndex>
#include <QtCore/QStack>

// common's headers
#include <Logger>
#include <General>
#include <BaloonNotificationManager>

// local headers
#include "filemanager.h"
#include "usermessages"
#include "../copymanager/copymanager.h"
#include "FileSystemOperations"

#define FILEMANAGER "Filemanager"

Filemanager::Filemanager():
	m_foldersModel(0),
	m_filesModel(0),
	m_splitter(0),
	m_files(0),
	m_gridLayout(0)
{
}

Filemanager::~Filemanager()
{
	BaloonNotificationManager::waitForBaloonsToFinish();
	
	// destroying all used data
	Logger::getInstance()->addInfo( "Filemanager is going down", FILEMANAGER );
	Logger::destroyInstance();
	delete m_files;
	delete m_filesModel;
	delete m_foldersModel;
	delete m_splitter;
	delete m_gridLayout;
}

void Filemanager::initEnvironement()
{
	// creating logger instance
	if( (false == Logger::createInstance()) || (false == Logger::getInstance()->setLogFile()) )
	{
		Logger::destroyInstance();
		messageBoxError("Can't init Logger");
		qApp->exit(1);
	}
	
	// setting up the GUI generated by designer
	setupUi(this);
	
	// setting up the directory tree
	setupFolders();
	
	// setting up the files view
	setupFiles();
	
	// setting up the store-pannel
	setupStorePanel();
	
	// setting up the trash
	setupTrash();
	
	// setting-up the the splitter
	m_splitter = new QSplitter( Ui::Filemanager::centralWidget );
	m_splitter->addWidget( m_folders );
	m_splitter->addWidget( m_files );
	
	// after adding the splitter , we have to re-layout the widgets
	m_gridLayout = new QGridLayout( Ui::Filemanager::centralWidget );
	m_gridLayout->addWidget( m_splitter, 0, 0 );
	m_gridLayout->addWidget( m_operations, 1, 0 );
	
	Logger::getInstance()->addInfo( "Filemanager is up and running", FILEMANAGER );
}

void Filemanager::setupFolders()
{
	m_foldersModel = new QDirModel();
	m_foldersModel->setFilter( QDir::AllDirs );
	m_foldersModel->setReadOnly( false );

	m_folders->setModel( m_foldersModel );
	int column = m_foldersModel->columnCount( QModelIndex() );
	for( --column; column > 0; --column )
	{
		// hiding all the collumns except the 'Name'
		m_folders->hideColumn( column );
	}
	
	// handling mouse's events on folders-tree
	connect( m_folders, SIGNAL(clicked(const QModelIndex&)),					this, SLOT(folderClick(const QModelIndex &))		);
	connect( m_folders, SIGNAL(customContextMenuRequested(const QPoint&)),	this, SLOT(folderRightClick(const QPoint&))		);
	connect( m_folders, SIGNAL(collapsed(const QModelIndex&)),				this, SLOT(foldersTreeChangedWidth())			);
	connect( m_folders, SIGNAL(expanded(const QModelIndex&)),				this, SLOT(foldersTreeChangedWidth())			);

}

void Filemanager::setupFiles()
{
	m_filesModel = new FilesModel();
	
	m_files = new FilesView( Ui::Filemanager::centralWidget );
	m_files->setObjectName(QString::fromUtf8("m_files"));
	m_files->setModel( m_filesModel );
	
	// setting the gui part for the view
	m_files->setAlternatingRowColors( true );
	m_files->setFlow( QListView::TopToBottom );
	m_files->setWrapping( true );
	m_files->setMovement( QListView::Static );
	m_files->setLayoutMode( QListView::Batched );
	m_files->setResizeMode( QListView::Adjust );
	m_files->setViewMode( QListView::ListMode );
	m_files->setSelectionBehavior( QListView::SelectRows );
	m_files->setSelectionMode( QListView::ExtendedSelection ); 
	
	// setting the view's mouse properties
	m_files->setAcceptDrops( true );
	m_files->setDragEnabled( true );
	m_files->setContextMenuPolicy( Qt::CustomContextMenu );
	m_files->setDragEnabled( true );
	m_files->setDropIndicatorShown( true );
	m_files->setEditTriggers( QAbstractItemView::NoEditTriggers );
	
	connect( m_files, SIGNAL(customContextMenuRequested(const QPoint &)),	this, SLOT(filesRightClick(const QPoint&)) );
	connect( m_files, SIGNAL(drop(QDropEvent*)),								this, SLOT(filesDrop(QDropEvent*)) );
	connect( m_files, SIGNAL(doubleClicked(const QModelIndex&)),				this, SLOT(filesDoubleClicked(const QModelIndex&)) );
	connect( m_files, SIGNAL(keyPress(QKeyEvent*)),							this, SLOT(filesKeyPress(QKeyEvent*)) );
	
	// creating a popup menu for rightClick on files
	m_filesRightClickMenu.addAction("Execute", this, SLOT(filesExecute()));
	m_filesRightClickMenu.addSeparator();
	m_filesRightClickMenu.addAction("Cut", this, SLOT(filesCut()));
	m_filesRightClickMenu.addAction("Copy", this, SLOT(filesCopy()));
	m_filesRightClickMenu.addAction("Paste", this, SLOT(filesPaste()));
	m_filesRightClickMenu.addSeparator();
	m_filesRightClickMenu.addAction("Delete", this, SLOT(filesDelete()));
}

// setting up the store-panel
void Filemanager::setupStorePanel()
{
	
}
	
// setting up the trash
void Filemanager::setupTrash()
{
	
}

void Filemanager::folderClick( const QModelIndex & index )
{
	// getting the path of the foldr on the file system
	m_currentFolder = m_foldersModel->filePath( index );
		
	// getting the folder's content and information about files
	m_filesModel->setCurrentFolder( m_currentFolder );
}

void Filemanager::folderRightClick( const QPoint & )
{
	messageBoxInfo( "right - click" );
}

void Filemanager::foldersTreeChangedWidth()
{
	m_folders->resizeColumnToContents( 0 );
}

void Filemanager::filesRightClick( const QPoint& point )
{
	m_filesRightClickMenu.exec( m_files->mapToGlobal(point) );
}

void Filemanager::filesDrop( QDropEvent * event )
{
	// getting the mime-data object
	const QMimeData* mimeData = event->mimeData();

	// checking for URLs
	if( !mimeData->hasUrls() )
		return;
		
	bool moveAction = (event->keyboardModifiers() == Qt::ShiftModifier);

	QList<QUrl> urls = mimeData->urls();
	foreach( QUrl url, urls )
	{
		if( false == url.toLocalFile().isEmpty() )
			CopyManager::addToCopyList( url.toLocalFile(), m_filesModel->getCurrentFolder(), moveAction, this );
	}
}

void Filemanager::copyManagerFinished()
{
	// refreshing the information on the file panels
	refreshCurrentFolder();
}

void Filemanager::copyManagerHasErrors( QString error )
{
	BaloonNotificationManager::showBaloonNotification( error );
}

void Filemanager::filesDoubleClicked( const QModelIndex& index )
{
	filesExecute();
}

void Filemanager::filesKeyPress( QKeyEvent* event )
{
	// getting the key that was pressed
	Qt::Key pressedKey = static_cast<Qt::Key>(event->key());
	
	// choosing an appropiate action
	switch( pressedKey )
	{
		// in case of 'Enter' we execute the file or change directory
		case Qt::Key_Return:
			filesExecute();
			break;

		// in case of 'Delete' we delete the selected items, be it a folder or simple file
		case Qt::Key_Delete:
			filesDelete();
			break;
			
		// Ctrl+C - the copy operation
		case Qt::Key_C:
			if( Qt::ControlModifier == event->modifiers() )
				filesCopy();
			break;		

		// Ctrl+X - the cut operation
		case Qt::Key_X:
			if( Qt::ControlModifier == event->modifiers() )
				filesCut();
			break;		

		// Ctrl+V - the paste operation
		case Qt::Key_V:
			if( Qt::ControlModifier == event->modifiers() )
				filesPaste();
			break;		

		default:
			break;
	}
}

void Filemanager::changeDirectory( QString folderPath )
{
	messageBoxInfo( "change-directory" );
}

void Filemanager::refreshCurrentFolder()
{
	// refreshing for the files
	m_filesModel->setCurrentFolder( m_currentFolder );
	
	// refreshing for the folders
//	QModelIndex currentIndex = m_folders->currentIndex();
//	QStack<QPersistentModelIndex> stack;
//	while( currentIndex.isValid() )
//	{
//		Logger::getInstance()->addInfo( currentIndex.data().toString() );
//		stack.push( QPersistentModelIndex(currentIndex) );
//		currentIndex = currentIndex.parent(); 
//	}
//
//	m_foldersModel->setFilter( QDir::AllDirs );
//	
//	while( false == stack.isEmpty() )
//	{
//		QPersistentModelIndex index = stack.pop();
//		Logger::getInstance()->addInfo( index.data().toString() );
//		m_folders->setExpanded( index, true );
//	}
}

void Filemanager::filesDelete()
{
	// getting the selected items
	QModelIndexList selectedItems = m_files->selectionModel()->selectedIndexes();
	
	// removing each item from File System
	for( QModelIndexList::iterator item = selectedItems.begin(); item != selectedItems.end(); ++item )
	{
		QString itemDisplayName = m_filesModel->data(*item,Qt::DisplayRole).toString();
		if( (itemDisplayName == "..") || (itemDisplayName == ".") )
			continue;
		
		QString itemName = m_filesModel->data(*item,Qt::StatusTipRole).toString();
		if( QFileInfo(itemName).isFile() )
		{
			if( false == removeFile(itemName) )
				BaloonNotificationManager::showBaloonNotification(QString(ERROR_ON_FILE_REMOVE).arg(itemName));
		}
		else 
		{
			if( false == removeFolder(itemName) )
				BaloonNotificationManager::showBaloonNotification(QString(ERROR_ON_FOLDER_REMOVE).arg(itemName));
		}
	}
	
	// refreshing the content for current folder
	refreshCurrentFolder();
}

void Filemanager::filesCut()
{
	messageBoxInfo( "cut" );
}

void Filemanager::filesCopy()
{
	messageBoxInfo( "copy" );
}

void Filemanager::filesPaste()
{
	messageBoxInfo( "paste" );
}

void Filemanager::filesExecute()
{
	messageBoxInfo( "execute" );
//	// getting the item's name being hit
//	QString itemName = m_filesModel->data(index,Qt::StatusTipRole).toString();
//	
//	// in dependence it is a file or folder we different things
//	if( QFileInfo(itemName).isFile() )
//		executeFile( itemName );
//	else
//		changeDirectory( itemName );
}
